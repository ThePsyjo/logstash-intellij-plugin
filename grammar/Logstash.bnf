{
 parserClass="com.github.redfoos.logstash.LogstashParser"



 extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

 psiClassPrefix="Logstash"
 psiImplClassSuffix="Impl"
 psiPackage="com.github.redfoos.logstash.psi"
 psiImplPackage="com.github.redfoos.logstash.psi.impl"
 elementTypeHolderClass="com.github.redfoos.logstash.psi.LogstashTypes"
 elementTypeClass="com.github.redfoos.logstash.psi.LogstashElementType"
 tokenTypeClass="com.github.redfoos.logstash.psi.LogstashTokenType"

tokens= [
    IF_TOK='if'
    ELSE_TOK='else'
    SINGLE_QUOTE="'"
    LBRACE='{'
    RBRACE='}'
    RIGHTARROW='=>'
    LBRACKET='['
    RBRACKET=']'
    LPARENTH='('
    RPARENTH=')'
    COMMA=','
    EQUAL='=='
    NEQUAL='!='
    LESS_OR_EQUAL='<='
    MORE_OR_EQUAL='>='
    LESS='<'
    MORE='>'
    REGEXPEQUAL='=~'
    REGEXPNEQUAL='!~'
    LOGICAL_NOT='!'
    AND='and'
    IN='in'
    XOR='xor'
    NAND='nand'
    OR='or'
    NOT='not'

]

}

logstashConfig ::= element (element)*

private element ::= COMMENT | plugin_block

plugin_block ::= block_name '{' (branch_or_plugin)* '}' {pin=1}

private branch_or_plugin ::= plugin | branch

plugin ::= IDENTIFIER '{' attributes '}'

private block_name ::= ('input' | 'filter' | 'output')

private attributes ::= (attribute (attribute)*)?

attribute ::= IDENTIFIER '=>' value

private value ::= plugin | bareword | STRING | NUMBER | array | hash

bareword ::= IDENTIFIER

array ::= '[' (value (',' value)*)? ']'

hash ::= '{' hashentries? '}'

hashentries ::= hashentry (hashentry)*

hashentry ::= (NUMBER | bareword | STRING) '=>' value

// Conditions

branch ::= if (else_if)* (else)?

// it's better to use most general 'expression' here. In future you may write an inspection that reports if-statements with non-boolean expressions
if ::= 'if' condition '{' (branch_or_plugin)* '}' {pin=1} // it's necessary to quote 'if' token because there is a rule with the same name

else_if ::= 'else' 'if' condition '{' (branch_or_plugin)* '}'

else ::= 'else' '{' (branch_or_plugin)* '}'

;{
  extends(".*_expression")=expression // !!! see https://github.com/JetBrains/Grammar-Kit/blob/master/HOWTO.md#24-compact-expression-parsing-with-priorities
}

private condition ::= expression (boolean_operator expression)*


// todo: check operators priority
expression ::=
    "(" condition ")"
   | negative_expression
   | in_expression
   | not_in_expression
   | compare_expression
   | regexp_expression
   | rvalue


negative_expression ::= ('!' '(' condition ')') | ('!' selector)

in_expression ::= rvalue in_operator rvalue // it's better to inline tiny private rules that are used only ones
not_in_expression ::= rvalue not_in_operator rvalue
private in_operator ::= 'in'
private not_in_operator ::= 'not' 'in' {pin=1}

private rvalue ::= STRING | NUMBER | selector | method_call | regexp

method_call ::= method '(' (rvalue (',' rvalue)* )? ')'

private method ::= bareword

compare_expression ::= rvalue compare_operator rvalue

private compare_operator ::= '==' | '!=' | '<=' | '>=' | '<' | '>'

regexp_expression ::= rvalue regexp_operator (STRING | regexp)

private regexp_operator ::= '=~' | '!~'

private boolean_operator ::= 'and' | 'or' | 'xor' | 'nand'

selector ::= selector_element+

private selector_element ::= array